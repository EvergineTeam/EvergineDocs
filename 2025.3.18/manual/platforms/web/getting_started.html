<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Getting Started with an Evergine Web Application | Evergine Doc </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Getting Started with an Evergine Web Application | Evergine Doc ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.min.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
  
  <meta property="docfx:rel" content="../../../">
  
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container flex-container">
            <label for="version" class="select-label">Version:</label>
            <select id="select-version" class="select-version" name="version" title="version">
            </select>
            <div class="hide-when-search" id="breadcrumb">
              <ul class="breadcrumb">
                <li></li>
              </ul>
            </div>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="getting-started-with-an-evergine-web-application">Getting Started with an Evergine Web Application</h1>

<hr>
<h2 id="create-a-new-application">Create a New Application</h2>
<p>From the Evergine launcher, you can create a Web (WebGL 2.0) project or add the web profile from the Evergine Studio.</p>
<p><img src="images/launcher.png" alt="Create a new Web project"></p>
<p>Evergine now offers two web templates: an HTML5 web template and a ReactJS web template. Both options are designed to execute Evergine in a web canvas, allowing for flexibility in your web development approach.</p>
<p>This template adds two projects to the web solution: the <em>Web</em> project, which is the web application client that uses TypeScript to execute Evergine in a web canvas, and an optional <em>Server</em> project, which is an ASP server application that implements some optimizations for asset loading that can only be done from the server side.</p>
<p><img src="images/explorer.png" alt="Web projects"></p>
<p>After editing your scene in Evergine Studio as usual, run the <em>Web.Server</em> project or the <em>Web</em> project from Visual Studio 2022 to see it running in the browser.</p>
<p><img src="images/sample.png" alt="Robot sample"></p>
<p>For the ReactJS template, the web solution includes a different set of projects: the Host project (equivalent to the Server project in the HTML5 template), the WebReact project (similar to the Web project), and an additional react.spa project, which holds the code for the single-page application (SPA).</p>
<p><img src="images/explorer-react.png" alt="Web projects"></p>
<p>Finally, check out <a href="ops.html">how to deploy the app</a> and <a href="tips.html">improve its performance</a>.</p>
<h3 id="reactjs-web-template">ReactJS Web Template</h3>
<p>The ReactJS template for Evergine uses the <strong>evergine-react</strong> NPM package, which is registered on <a href="https://www.npmjs.com/package/evergine-react">npmjs.com/package/evergine-react</a>. This package contains a set of helper components designed to facilitate interaction with Evergine within a ReactJS single-page application (SPA).</p>
<p>The main component provided by this package is the <em>EvergineCanvas</em>, which is used in the <em>App.tsx</em> file. This component renders the HTML5 canvas where Evergine will be executed. Another important file is <em>evergine-initialize.ts</em>, which is responsible for managing communication between the SPA and Evergine via a WebAssembly (WASM) JavaScript bridge.</p>
<p>The <strong>evergine-react</strong> package also includes a state store for Evergine, which holds two key values:</p>
<ul>
<li><strong>webAssemblyLoaded</strong>: Becomes <strong>true</strong> once WASM has been successfully loaded.</li>
<li><strong>evergineReady</strong>: Becomes <strong>true</strong> once Evergine has initialized all necessary assets.</li>
</ul>
<p>It’s recommended to wait for both of these values to be <strong>true</strong> before initiating any custom communication between the SPA and Evergine. This helps prevent potential race conditions that could occur if communication is attempted too early.</p>
<p>For example, following code snippet modifies the <em>App.tsx</em> file to include a text message that will be displayed while Evergine is loading.</p>
<pre><code class="lang-typescript">import './App.css';
import { useEvergineStore, EvergineCanvas } from &quot;evergine-react&quot;;
import { EVERGINE_CANVAS_ID } from &quot;evergine/config&quot;;
import { useWindowSize } from &quot;evergine/useWindowSize&quot;;

function App() {
    const { webAssemblyLoaded, evergineReady } = useEvergineStore();

    return (
        &lt;div className=&quot;App&quot;&gt;
            {(!webAssemblyLoaded || !evergineReady) &amp;&amp; (&lt;div&gt;Loading Evergine...&lt;/div&gt;)}
            &lt;EvergineCanvas
                canvasId={EVERGINE_CANVAS_ID}
                width={useWindowSize().width}
                height={useWindowSize().height}
            /&gt;
        &lt;/div&gt;
    );
}

export default App;
</code></pre>
<p>When you build the SPA (react.spa) project, all required code and dependencies will be copied into the <strong>public</strong> folder. This folder contains the SPA code that embeds the Evergine canvas and can be deployed as a static website.</p>
<p><img src="images/reactjs_public-folder.png" alt="ReactJS public folder"></p>
<h3 id="invoking-functions-between-spa-and-evergine">Invoking Functions Between SPA and Evergine</h3>
<p>In Evergine, communication between the single-page application (SPA) and the engine is facilitated through function invocations in both directions: from the SPA to Evergine and from Evergine to the SPA. This process enables dynamic interactions, such as triggering engine events from the UI or responding to engine updates in real-time.</p>
<p>Evergine also includes <a href="serialization.html">built-in JSON serializers</a> to manage the serialization and deserialization of objects exchanged across the JavaScript and .NET boundary via the JS bridge. These serializers ensure that data structures are accurately converted, making it straightforward to pass complex objects between JavaScript and .NET in both directions.</p>
<p>In the following steps, we will demonstrate how to set up these function invocations, starting with calls from the SPA to Evergine and then covering calls from Evergine back to the SPA. Each step is accompanied by code examples to illustrate the process.</p>
<h4 id="step-1-adding-a-custom-scene-manager-for-communication">Step 1: Adding a Custom Scene Manager for Communication</h4>
<p>To handle communication between the SPA and Evergine, we first need to add a custom scene manager. This manager will serve as the central point for invoking functions from the SPA to Evergine and for receiving callbacks from Evergine back to the SPA.</p>
<p>In this example, we will define a callback class that must be implemented in the WebReact project. In WebFacade class will include methods to handle two-way communication: sending messages from the SPA to Evergine and receiving messages back from Evergine to the SPA.</p>
<p>The following code snippet demonstrates how to create the custom scene manager and the callback class:</p>
<pre><code class="lang-csharp">public class MySceneManager : SceneManager
{
    public EvergineCallbacks Callbacks { get; set; }

    public void MessageToEvergine(string message)
    {
        Console.WriteLine(message);
        _ = Task.Run(async () =&gt;
        {
            await Task.Delay(2000);
            this.Callbacks?.MessageFromEvergine(&quot;Hello from Evergine!&quot;);
        });
    }

    public abstract class EvergineCallbacks
    {
        public abstract void MessageFromEvergine(string message);
    }
}
</code></pre>
<p>Once we've defined the custom scene manager, we need to register it within the <em>MyScene</em>.</p>
<pre><code class="lang-csharp">public class MyScene : Scene
{
    public override void RegisterManagers()
    {
        base.RegisterManagers();
        
        this.Managers.AddManager(new global::Evergine.Bullet.BulletPhysicManager3D());
        this.Managers.AddManager(new MySceneManager());
    }

    protected override void CreateScene()
    {
    }
}
</code></pre>
<h4 id="step-2-extend-webfacade-in-web-project">Step 2: Extend <em>WebFacade</em> in web project</h4>
<p>Next, we’ll extend the WebFacade to add new communication methods that can invoke functions between the SPA and Evergine. This is where we define how the SPA will communicate with the scene manager and vice versa.</p>
<p><em>WebFacade.cs</em></p>
<pre><code class="lang-csharp">public static class WebFacade
{        
    private const string BaseInvokeClassName = &quot;Sample.WebReact.WebFacade&quot;;

    private static MySceneManager sceneManager;

    public static MySceneManager SceneManager
    {
        get =&gt; sceneManager;
        set
        {
            sceneManager = value;
            sceneManager.Callbacks = new WebCallbacks();
        }
    }

    // ...
    [JSInvokable($&quot;{BaseInvokeClassName}:MessageToEvergine&quot;)]
    public static void MessageToEvergine(string message) =&gt; SceneManager?.MessageToEvergine(message);

    private class WebCallbacks : EvergineCallbacks
    {
        public override void MessageFromEvergine(string message)
        {
            Program.Wasm.Invoke(&quot;App.appEventsListener.onMessageFromEvergine&quot;, args: message);
        }
    }
}
</code></pre>
<p><em>Program.cs</em></p>
<pre><code class="lang-csharp">private static void ScreenContextManager_OnActivatingScene(Scene scene)
{
    var sceneManager = scene.Managers.FindManager&lt;MySceneManager&gt;();
    WebFacade.SceneManager = sceneManager;

    Wasm.Invoke(&quot;App.appEventsListener.onEvergineReady&quot;, false, true);
}

private static void ScreenContextManager_OnDesactivatingScene(Scene scene)
{
    WebFacade.SceneManager = null;
    Wasm.Invoke(&quot;App.appEventsListener.onEvergineReady&quot;, false, false);
}
</code></pre>
<h4 id="step-3-adding-invokes-and-callbacks-in-evergine-initializets">Step 3: Adding Invokes and Callbacks in <em>evergine-initialize.ts</em></h4>
<p>To complete the communication setup between the SPA and Evergine, we will modify the <em>evergine-initialize.ts</em> file. In this step, we’ll extend the AppEventsListener to handle invokes coming from Evergine, and we’ll extend WebEventsProxy to define methods that the SPA can use to send messages to Evergine.</p>
<pre><code class="lang-typescript">import { initializeEvergineBase } from &quot;evergine-react&quot;;

import {
  EVERGINE_ASSEMBLY_NAME,
  EVERGINE_CLASS_NAME,
  EVERGINE_LOADING_BAR_ID,
} from &quot;evergine/config&quot;;

declare global {
  let Blazor: { start(): Promise&lt;void&gt; };  

  interface AppEventsListener {
    onMessageFromEvergine: (message: string) =&gt; void
  }
  interface WebEventsProxy {
    sendMessageToEvergine: (message: string) =&gt; void;
  }
}

function addCustomEvents() {
    window.App.appEventsListener.onMessageFromEvergine = (message: string): void =&gt;
        console.log(message);
    window.App.webEventsProxy.sendMessageToEvergine = (message: string): void =&gt;
        window.Utils.invoke(&quot;MessageToEvergine&quot;, message);
}

const initializeEvergine = (): void =&gt; {
  initializeEvergineBase(
    EVERGINE_LOADING_BAR_ID,
    EVERGINE_ASSEMBLY_NAME,
    EVERGINE_CLASS_NAME,
    addCustomEvents
  );
};

export { initializeEvergine };
</code></pre>
<p>With this setup in place, you can test the communication by invoking the method directly from the browser’s development console. For example, to send a message from the SPA to Evergine, you can call the following in the console:</p>
<pre><code class="lang-javascript">App.webEventsProxy.sendMessageToEvergine(&quot;Hello from SPA!&quot;)
</code></pre>
<p>This will trigger the sendMessageToEvergine method. After two seconds, a message saying &quot;Hello from Evergine!&quot; will be sent back to the SPA and displayed in the console.</p>
<pre><code>Hello from Evergine!
</code></pre>
<p>This is only one possible approach to setting up communication between the SPA and Evergine. You are free to define your own method for handling this interaction based on your specific requirements.</p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">

              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In this article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
        
        <span>Generated by <strong>DocFX</strong></span>
            </div>      
          </div>
        </div>
      </footer>    </div>

    <script type="text/javascript" src="../../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
