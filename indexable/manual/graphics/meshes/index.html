<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Meshes | Evergine Doc </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Meshes | Evergine Doc ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.min.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
  
  <meta property="docfx:rel" content="../../../">
  
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container flex-container">
            <label for="version" class="select-label">Version:</label>
            <select id="select-version" class="select-version" name="version" title="version">
            </select>
            <div class="hide-when-search" id="breadcrumb">
              <ul class="breadcrumb">
                <li></li>
              </ul>
            </div>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="meshes">Meshes</h1>

<p><img src="images/Meshes.jpg" alt="Meshes"></p>
<h2 id="introduction">Introduction</h2>
<p>A mesh is a single drawable element, a fundamental structure used to represent 3D objects in a scene. It is composed of vertices (points in 3D space) that are connected to form polygons, typically triangles. It also is rendered with only one <strong>Material</strong>.</p>
<p>Each vertex in a mesh can hold additional information, such as normals (which define the direction a surface is facing), UV coordinates (which map textures to the object), and color or other custom data. This allows the mesh to have detailed surface characteristics, like how it reflects light or how a texture is applied to it.</p>
<p>Complex models contains multiple meshes with multiple materials, as defined in this article.</p>
<h4 id="parameters">Parameters</h4>
<p>The <em>Evergine</em> mesh class contains the following parameters.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>VertexBuffers</strong></td>
<td><code>VertexBuffer[]</code>.</td>
<td>Array containing  the vertex buffers of the mesh (explained <a href="#vertex-buffers">here</a>)</td>
</tr>
<tr>
<td><strong>IndexBuffer</strong></td>
<td><code>IndexBuffer</code>.</td>
<td>The mesh index buffer. Can be null (explained <a href="#index-buffers">here</a>)</td>
</tr>
<tr>
<td><strong>Buffers</strong></td>
<td><code>Buffer[]</code>.</td>
<td>Array containing all the <strong>Buffer</strong> instances of every vertex buffer.</td>
</tr>
<tr>
<td><strong>Offsets</strong></td>
<td><code>int[]</code>.</td>
<td>Array containing all the vertex offsets of every vertex buffer.</td>
</tr>
<tr>
<td><strong>PrimitiveTopology</strong></td>
<td><code>PrimitiveTopology</code>.</td>
<td>Enumeration containing the type of geometric topology used for the  mesh.  Its values are: <li>Undefined</li><li>PointList</li><li>LineList</li><li>LineStrip</li><li>TriangleList</li><li>TriangleStrip</li><li>LineListWithAdjacency</li><li>TriangleListWithAdjacency</li><li>Patch_List</li></td>
</tr>
<tr>
<td><strong>InputLayouts</strong></td>
<td><code>InputLayouts</code>.</td>
<td>Object containing the LayoutDescription of every vertex buffer.</td>
</tr>
<tr>
<td><strong>Primitive Count</strong></td>
<td><code>int</code>.</td>
<td>The number of primitives of the mesh.</td>
</tr>
<tr>
<td><strong>ElementCount</strong></td>
<td><code>int</code>.</td>
<td>The number of elements in the mesh. It's affected by the topology (For example, 1 triangle contains 3 elements, but 1 line is made of 2).</td>
</tr>
<tr>
<td><strong>VertexSize</strong></td>
<td><code>ushort</code>.</td>
<td>The memory size (in bytes) of a single vertex.</td>
</tr>
<tr>
<td><strong>AllowBatching</strong></td>
<td><code>bool</code>.</td>
<td>If the mesh can be used in dynamic and static batching.</td>
</tr>
</tbody>
</table>
<h2 id="vertex-buffers">Vertex Buffers</h2>
<p>The <em>VertexBuffer</em> class in Evergine represents a buffer that holds the vertex data required for rendering 3D objects.
It mainly contains the <strong>Buffer</strong> that contains the raw data and the <strong>LayoutDescription</strong> declaring what kind of vertex information it has.
The Vertex Buffer plays a crucial role in managing the vertex layouts and size, ensuring that this data can be processed efficiently by the GPU. The VertexBuffer class handles data organization and allows developers to define how vertex attributes like positions, normals, and textures are stored.</p>
<h3 id="interleaved-and-non-interleaved-data">Interleaved and Non-Interleaved Data</h3>
<p>It's common to think of a vertex as a single entity (an object that holds all its relevant data). However, we can also get vertex attributes from separate streams, where the data for each attribute (like position, normals, or colors) is stored in contiguous memory blocks: one for positions, another for normals, and so on.</p>
<p>This approach offers several advantages. For example, it allows vertex data to be accessed by different Vertex Shaders without wasting bandwidth or cache space. In cases where a vertex is processed for a shadow map, the vertex function might only require the position, not the other attributes. If all vertex data is stored together, the GPU would have to traverse more memory to retrieve only the needed data. Additionally, optimizing the layout of this data within a struct can be tricky due to alignment and cache considerations.</p>
<h4 id="interleaved-vertex-attributes">Interleaved Vertex Attributes</h4>
<p><img src="images/InterleavedData.png" alt="Interleaved"></p>
<h4 id="non-interleaved-vertex-attributes">Non-interleaved Vertex Attributes</h4>
<p><img src="images/NonInterleavedData.png" alt="Non-Interleaved"></p>
<p>As we can see,  vertex data can be arranged either with all attributes of a vertex stored together (<strong>interleaved</strong>) or with each attribute type stored together across all vertices (<strong>non-interleaved</strong>).</p>
<h3 id="parameters-1">Parameters</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Buffer</strong></td>
<td><code>Buffer</code>.</td>
<td>Buffer containing the vertex data. The buffer must contain the flag  <code>BufferFlag.VertexBuffer</code>. Otherwise it won't be accepted.</td>
</tr>
<tr>
<td><strong>Size</strong></td>
<td><code>int</code>.</td>
<td>Size of the buffer in bytes.</td>
</tr>
<tr>
<td><strong>Offset</strong></td>
<td><code>int</code>.</td>
<td>The offset in  bytes of the buffer data.</td>
</tr>
<tr>
<td><strong>Data</strong></td>
<td><code>IntPtr</code>.</td>
<td>Pointer of the raw memory data of the buffer.</td>
</tr>
<tr>
<td><strong>LayoutDescription</strong></td>
<td><code>LayoutDescription</code>.</td>
<td>Description of the different <strong>ElementDescription</strong> instances, explaining the type of information, semantics, stride and offsets the vertex contains, allowing to properly extract the data.</td>
</tr>
<tr>
<td><strong>VertexCount</strong></td>
<td><code>int</code>.</td>
<td>The number of vertices to be fetched from the buffer.</td>
</tr>
</tbody>
</table>
<h3 id="predefined-vertices-structures">Predefined Vertices structures.</h3>
<p>In order to make it easier for developers, <strong>Evergine</strong> contains a set of structs that can be used to define vertices with different kind of information. Our predefine types are:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>VertexPosition</strong></td>
<td>Struct of vertex containing only <code>Position</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionColor</strong></td>
<td>Struct of vertex containing the properties <code>Position</code> and <code>Color</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionColorDualTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Color</code>, <code>TexCoord</code> and <code>TexCoord2</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionColorTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Color</code> and <code>TexCoord</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionDualTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>TexCoord</code> and <code>TexCoord2</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionNormal</strong></td>
<td>Struct of vertex containing the properties <code>Position</code> and <code>Normal</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionNormalColor</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Normal</code> and <code>Color</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionNormalColorDualTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Normal</code>, <code>Color</code>, <code>TexCoord</code> and <code>TexCoord2</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionNormalColorTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Normal</code>, <code>Color</code> and <code>TexCoord</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionNormalDualTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Normal</code>, <code>TexCoord</code> and <code>TexCoord2</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionNormalTangentColorDualTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Normal</code>, <code>Tangent</code>, <code>Color</code>, <code>TexCoord</code> and <code>TexCoord2</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionNormalTangentTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Normal</code>, <code>Tangent</code>, <code>Color</code>, and <code>TexCoord</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionNormalTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code>, <code>Normal</code> and <code>TexCoord</code>.</td>
<td></td>
</tr>
<tr>
<td><strong>VertexPositionTexture</strong></td>
<td>Struct of vertex containing the properties <code>Position</code> and <code>TexCoord</code>.</td>
<td></td>
</tr>
</tbody>
</table>
<p>The advantage of using this structures is that they provide the <strong>LayoutDescription</strong> of that vertex. However, you can create your own <strong>VertexBuffers</strong> with your own arrays, but you will have to build the <strong>LayoutDescription</strong>.</p>
<h2 id="index-buffers">Index Buffers</h2>
<p>3D meshes you'll be rendering often have vertices that are shared across multiple triangles. This occurs even with simple shapes, like a rectangle:</p>
<p>Rendering a rectangle requires two triangles, which would normally mean a vertex buffer containing 6 vertices. However, two of these vertices would need to be duplicated, resulting in a 50% redundancy. This issue becomes more pronounced with complex meshes, where a single vertex is typically shared among 3 triangles. To solve this inefficiency, we use an index buffer.</p>
<p>An index buffer is essentially a list of references to the vertices in the vertex buffer. This allows for rearranging the vertex data and reusing vertices across multiple triangles without duplicating data. In the example of a rectangle, if the vertex buffer contains four unique vertices, the index buffer would reference these vertices, with the first three indices forming the top-right triangle, and the last three creating the bottom-left triangle.</p>
<h4 id="parameters-2">Parameters</h4>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Buffer</strong></td>
<td><code>Buffer</code>.</td>
<td>Buffer containing the indices data. The buffer must contain the flag  <code>BufferFlag.IndexBuffer</code>. Otherwise it won't be accepted.</td>
</tr>
<tr>
<td><strong>Size</strong></td>
<td><code>int</code>.</td>
<td>Size of the buffer in bytes.</td>
</tr>
<tr>
<td><strong>Offset</strong></td>
<td><code>int</code>.</td>
<td>The offset in  bytes of the buffer data.</td>
</tr>
<tr>
<td><strong>Data</strong></td>
<td><code>IntPtr</code>.</td>
<td>Pointer of the raw memory data of the buffer.</td>
</tr>
<tr>
<td><strong>IndexFormat</strong></td>
<td><code>IndexFormat</code>.</td>
<td>The type of index. Can be <strong>Uint16</strong> (<em>unsigned short</em>) or <strong>UInt32</strong> (<em>unsigned int</em>).</td>
</tr>
<tr>
<td><strong>FlipWinding</strong></td>
<td><code>bool</code>.</td>
<td>If true, the triangle side is defined in counter clock-wise order.</td>
</tr>
<tr>
<td><strong>IndexCount</strong></td>
<td><code>int</code>.</td>
<td>Number of indices.</td>
</tr>
</tbody>
</table>
<h2 id="create-mesh-from-code">Create Mesh from Code</h2>
<h3 id="simple-mesh-using-a-predefined-type">Simple mesh using a predefined type</h3>
<p>The next code explain how to create a simple mesh. It uses the <strong>VertexPositionColor</strong> struct for defining its data:</p>
<pre><code class="lang-csharp">// Vertices and indices data.
ushort[] indexData = new ushort[] { 0, 1, 2, 0, 2, 3 };

VertexPositionColor[] vertexData = new VertexPositionColor[]
{
    new VertexPositionColor(new Vector3(-0.5f, 0.5f, 0.0f), Color.Blue),
    new VertexPositionColor(new Vector3(0.5f, 0.5f, 0.0f), Color.Red),
    new VertexPositionColor(new Vector3(0.5f, -0.5f, 0.0f), Color.Green),
    new VertexPositionColor(new Vector3(-0.5f, -0.5f, 0.0f), Color.Yellow),
};

// Vertex Buffer
var vBufferDescription = new BufferDescription()
{
    SizeInBytes = (uint)Unsafe.SizeOf&lt;VertexPositionColor&gt;() * (uint)this.vertexData.Length,
    Flags = BufferFlags.ShaderResource | BufferFlags.VertexBuffer,
    Usage = ResourceUsage.Default
};

// We create the buffer using the vertex array data previously defined.
Buffer vBuffer = graphicsContext.Factory.CreateBuffer(this.vertexData, ref vBufferDescription);
VertexBuffer vertexBuffer = new VertexBuffer(vBuffer, VertexPositionColor.VertexFormat);

// Index Buffer
var iBufferDescription = new BufferDescription()
{
    SizeInBytes = (uint)(sizeof(ushort) * this.indexData.Length),
    Flags = BufferFlags.IndexBuffer,
    Usage = ResourceUsage.Default,
};

// We create the buffer using the ushort array data previously defined.
Buffer iBuffer = graphicsContext.Factory.CreateBuffer(this.indexData, ref iBufferDescription);
var indexBuffer = new IndexBuffer(iBuffer);

// Create Mesh using the previously defined vertex buffer and index buffer.
return new Mesh(new VertexBuffer[] { vertexBuffer }, indexBuffer, PrimitiveTopology.TriangleList)
{
    BoundingBox = this.ComputeBoundingBox(),
};
</code></pre>
<h3 id="simple-mesh-using-your-own-arrays">Simple mesh using your own arrays</h3>
<p>This code, on the other hand, explain how to build your own mesh with your own data types.</p>
<pre><code class="lang-csharp">// Indices data array.
ushort[] indexData = new ushort[] { 0, 1, 2, 0, 2, 3 };

// Position data array.
Vector3[] positions = new Vector3[]
{
    new Vector3(-0.5f, 0.5f, 0.0f),
    new Vector3(0.5f, 0.5f, 0.0f),
    new Vector3(0.5f, -0.5f, 0.0f),
    new Vector3(-0.5f, -0.5f, 0.0f),
};

// Color data array.
Vector4[] colors = new Vector4[]
{
    Color.Blue.ToVector4(),
    Color.Red.ToVector4(),
    Color.Green.ToVector4(),
    Color.Yellow.ToVector4(),
};

// Vertex Buffer with the position attribute data.
var bufferPosDesc = new BufferDescription()
{
    SizeInBytes = (uint)Unsafe.SizeOf&lt;Vector3&gt;() * (uint)this.positions.Length,
    Flags = BufferFlags.ShaderResource | BufferFlags.VertexBuffer,
    Usage = ResourceUsage.Default,
};

Buffer bufferPos = graphicsContext.Factory.CreateBuffer(this.positions, ref bufferPosDesc);
LayoutDescription layoutPos = new LayoutDescription().Add(new ElementDescription(ElementFormat.Float3, ElementSemanticType.Position, 0, 0));
VertexBuffer vertexBufferPos = new VertexBuffer(bufferPos, layoutPos);

// Vertex Buffer with the color attribute data.
var bufferColorDesc = new BufferDescription()
{
    SizeInBytes = (uint)Unsafe.SizeOf&lt;Vector4&gt;() * (uint)this.colors.Length,
    Flags = BufferFlags.ShaderResource | BufferFlags.VertexBuffer,
    Usage = ResourceUsage.Default,
};

Buffer bufferColor = graphicsContext.Factory.CreateBuffer(this.colors, ref bufferColorDesc);
LayoutDescription layoutColor = new LayoutDescription().Add(new ElementDescription(ElementFormat.Float4, ElementSemanticType.Color, 0));
VertexBuffer vertexBufferColor = new VertexBuffer(bufferColor, layoutColor);

// Index Buffer
var iBufferDescription = new BufferDescription()
{
    SizeInBytes = (uint)(sizeof(ushort) * this.indexData.Length),
    Flags = BufferFlags.IndexBuffer,
    Usage = ResourceUsage.Default
};

Buffer iBuffer = graphicsContext.Factory.CreateBuffer(this.indexData, ref iBufferDescription);
var indexBuffer = new IndexBuffer(iBuffer);

// Create Mesh with the 2 previous vertex buffers and the index buffer.
return new Mesh(new VertexBuffer[] { vertexBufferPos, vertexBufferColor }, indexBuffer, PrimitiveTopology.TriangleList)
{
    BoundingBox = this.ComputeBoundingBox(),
};
</code></pre>
<p>In both cases the result will be the same:</p>
<p><img src="images/Quad.png" alt="Quad"></p>
<div class="NOTE">
<h5>Note</h5>
<p>In this <a href="../models/create_model_from_code.html">article</a> is explained how to show this custom mesh into a new entity.</p>
</div>
<p>For a single mesh Model, <strong>Evergine</strong> offers an easy way creating it, just passing it as a parameter in its constructor:</p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">

              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In this article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
        
        <span>Generated by <strong>DocFX</strong></span>
            </div>      
          </div>
        </div>
      </footer>    </div>

    <script type="text/javascript" src="../../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
