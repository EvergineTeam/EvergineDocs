# Using Compute Tasks

**Compute tasks** are very similar to Materials, they are an associated effect too and you also can generate a class decorator to using from code. The main difference is that the compute tasks only can be used from code. Compute Task decorator are generated from [Effect Editor](../effects/effect_editor.md) like [Material decorators](../materials/material_decorators.md).

The compute task decorator helps you set the compute effect resource layout. As input resources, you can use ConstantBuffers, StructureBuffer, Textures, and Samplers. This is an example of a compute task decorator with an input texture and output texture define in its resource layout block:

```csharp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DocumentationWorkBench.Effects
{
    using Evergine.Common.Graphics;
    using Evergine.Framework.Graphics;
    using Evergine.Framework.Graphics.Effects;
    using Evergine.Mathematics;
    
    
    [Evergine.Framework.Graphics.MaterialDecoratorAttribute("6ba492de-d165-4491-b5b0-ae72dc202577")]
    public partial class GPUFilter : Evergine.Framework.Graphics.ComputeTaskDecorator
    {
        
        public GPUFilter(Evergine.Framework.Graphics.Effects.Effect effect) : 
                base(new ComputeTask(effect))
        { }
        
        public GPUFilter(Evergine.Framework.Graphics.ComputeTask computeTask) : 
                base(computeTask)
        { }
        
        public Evergine.Common.Graphics.Texture Input
        {
            get { return this.material.TextureSlots[0].Texture; }
            set { this.material.SetTexture(value, 0); }
        }
        
        public Evergine.Common.Graphics.Texture Output
        {
            get { return this.material.UABuffers[0].UATexture; }
            set { this.material.SetUATexture(value, 0); }
        }
    }
}
```

To run a compute task you must call to `Run` methods and exists the following flavors:

| Method |  Description |
|--------| ----------- |
| Run    | Defines the groupcount X,Y and Z and the pass selected. |
| Run1D  | Helper method to run 1D tasks, only need to pass threadCount X the groupSizes are defined as (64,1,1). |
| Run2D  | Helper method to run 2D tasks, only need to pass ThreadCount X and Y, the groupSizes are defined as (8,8,1). |
| Run3D  | Helper method to run 3D tasks, is similar to run but you can define ThreadCounts X,Y,Z and GroupSizes X,Y,Z.|