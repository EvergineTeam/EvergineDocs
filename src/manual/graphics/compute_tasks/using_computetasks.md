# Using Compute Tasks

**Compute tasks** are very similar to Materials; they are associated effects too, and you can also generate a class decorator to use from code. The main difference is that compute tasks can only be used from code. Compute Task decorators are generated from [Effect Editor](../effects/effect_editor.md) like [Material decorators](../materials/material_decorators.md).

The compute task decorator helps you set the compute effect resource layout. As input resources, you can use ConstantBuffers, StructureBuffer, Textures, and Samplers. This is an example of a compute task decorator with an input texture and output texture defined in its resource layout block:

```csharp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DocumentationWorkBench.Effects
{
    using Evergine.Common.Graphics;
    using Evergine.Framework.Graphics;
    using Evergine.Framework.Graphics.Effects;
    using Evergine.Mathematics;
    
    
    [Evergine.Framework.Graphics.MaterialDecoratorAttribute("6ba492de-d165-4491-b5b0-ae72dc202577")]
    public partial class GPUFilter : Evergine.Framework.Graphics.ComputeTaskDecorator
    {
        
        public GPUFilter(Evergine.Framework.Graphics.Effects.Effect effect) : 
                base(new ComputeTask(effect))
        { }
        
        public GPUFilter(Evergine.Framework.Graphics.ComputeTask computeTask) : 
                base(computeTask)
        { }
        
        public Evergine.Common.Graphics.Texture Input
        {
            get { return this.material.TextureSlots[0].Texture; }
            set { this.material.SetTexture(value, 0); }
        }
        
        public Evergine.Common.Graphics.Texture Output
        {
            get { return this.material.UABuffers[0].UATexture; }
            set { this.material.SetUATexture(value, 0); }
        }
    }
}
```

To run a compute task, you must call the `Run` methods. The following variations exist:

| Method | Description |
|--------|-------------|
| Run    | Defines the group count X, Y, and Z and the selected pass. |
| Run1D  | Helper method to run 1D tasks; you only need to pass threadCount X. The groupSizes are defined as (64, 1, 1). |
| Run2D  | Helper method to run 2D tasks; you only need to pass ThreadCount X and Y. The groupSizes are defined as (8, 8, 1). |
| Run3D  | Helper method to run 3D tasks; it is similar to Run but allows you to define ThreadCounts X, Y, Z and GroupSizes X, Y, Z. |